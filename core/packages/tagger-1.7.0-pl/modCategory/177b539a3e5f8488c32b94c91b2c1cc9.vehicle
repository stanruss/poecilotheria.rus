<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Snippets' => 
    array (
      'e473f0a079fd4780838331cc9eba2491' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":0,"source":0,"property_preprocess":0,"name":"TaggerGetTags","description":"This Snippet allows you to list tags for resource(s), group(s) and all tags","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetTags\\n *\\n * DESCRIPTION\\n *\\n * This Snippet allows you to list tags for resource(s), group(s) and all tags\\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &rowTpl          string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl          string  optional    Name of a chunk that will be used for wrapping all tags. If no chunk is given, tags will be rendered without a wrapper\\n * &separator       string  optional    String separator, that will be used for separating Tags\\n * &limit           int     optional    Limit number of returned tag Tags\\n * &offset          int     optional    Offset the output by this number of Tags\\n * &totalPh         string  optional    Placeholder to output the total number of Tags regardless of &limit and &offset\\n * &target          int     optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * &toPlaceholder   string  optional    If set, output will return in placeholder with given name\\n * &sort            string  optional    Sort options in JSON. Example {\\"tag\\": \\"ASC\\"} or multiple sort options {\\"group_id\\": \\"ASC\\", \\"tag\\": \\"ASC\\"}\\n * &friendlyURL     int     optional    If set, will be used instead of friendly_urls system setting to generate URL\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetTags? &showUnused=`1`]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$showUnused = (int) $modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int) $modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int) $modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n$translate = (int) $modx->getOption(\'translate\', $scriptProperties, \'0\');\\n\\n$defaultRowTpl = $modx->getOption(\'rowTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, 1);\\n$separator = $modx->getOption(\'separator\', $scriptProperties, \'\');\\n$limit = intval($modx->getOption(\'limit\', $scriptProperties, 0));\\n$offset = intval($modx->getOption(\'offset\', $scriptProperties, 0));\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$weight = (int) $modx->getOption(\'weight\', $scriptProperties, \'0\');\\n\\n$friendlyURL = $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'{}\');\\n$sort = $modx->fromJSON($sort);\\nif ($sort === null || $sort == \'\' || count($sort) == 0) {\\n    $sort = array(\\n        \'tag\' => \'ASC\'\\n    );\\n}\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, \'\');\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\\n        \'Resource.context_key:IN\' => $contexts,\\n    ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n    ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n    ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\\n        \'cnt > 0\',\\n    ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\\n        \'Resources.resource:IN\' => $resources\\n    ));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n    ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) as total, MAX(cnt) as max_cnt FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\n\\nif ($stmt && $stmt->execute()) {\\n    $fetchedData = $stmt->fetch(PDO::FETCH_ASSOC);\\n    $total = intval($fetchedData[\'total\']);\\n    $maxCnt = intval($fetchedData[\'max_cnt\']);\\n} else {\\n    $total = 0;\\n    $maxCnt = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\nforeach ($sort as $field => $dir) {\\n    $dir = (strtolower($dir) == \'asc\') ? \'asc\' : \'desc\';\\n    $c->sortby($field, $dir);\\n}\\n\\n$c->limit($limit, $offset);\\n\\n$tags = $modx->getIterator(\'TaggerTag\', $c);\\n\\n$out = array();\\n\\n\\/\\/ prep for &tpl_N\\n$keys = array_keys($scriptProperties);\\n$nthTpls = array();\\nforeach($keys as $key) {\\n    $keyBits = $tagger->explodeAndClean($key, \'_\');\\n    if (isset($keyBits[0]) && $keyBits[0] === \'tpl\') {\\n        if ($i = (int) $keyBits[1]) $nthTpls[$i] = $scriptProperties[$key];\\n    }\\n}\\nksort($nthTpls);\\n\\n$idx = 1;\\nforeach ($tags as $tag) {\\n    \\/** @var TaggerTag $tag *\\/\\n    $phs = $tag->toArray();\\n\\n    $group = $tag->Group;\\n\\n    if ($friendlyURL == 1) {\\n        $uri = rtrim($modx->makeUrl($target, \'\', \'\'), \'\\/\') . \'\\/\' . $group->alias . \'\\/\' . $tag->alias . \'\\/\';\\n    } else {\\n        $uri = $modx->makeUrl($target, \'\', $group->alias . \'=\' . $tag->alias);\\n    }\\n\\n    $phs[\'uri\'] = $uri;\\n    $phs[\'idx\'] = $idx;\\n    $phs[\'target\'] = $target;\\n    $phs[\'max_cnt\'] = $maxCnt;\\n\\n    if ($weight > 0) {\\n        $phs[\'weight\'] = intval(ceil($phs[\'cnt\'] \\/ ($maxCnt \\/ $weight)));\\n    }\\n\\n    if ($translate == 1) {\\n        $groupNameTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\']);\\n        $groupDescriptionTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\');\\n\\n        $phs[\'group_name_translated\'] = ($groupNameTranslated == \'tagger.custom.\' . $phs[\'group_alias\']) ? $phs[\'group_name\'] : $groupNameTranslated;\\n        $phs[\'group_description_translated\'] = ($groupDescriptionTranslated == \'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\') ? $phs[\'group_description\'] : $groupDescriptionTranslated;\\n    }\\n\\n    $rowTpl = $defaultRowTpl;\\n    if ($rowTpl == \'\') {\\n        $out[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n    } else {\\n        if (isset($nthTpls[$idx])) {\\n            $rowTpl = $nthTpls[$idx];\\n        } else {\\n            foreach ($nthTpls as $int => $tpl) {\\n                if ( ($idx % $int) === 0 ) $rowTpl = $tpl;\\n            }\\n        }\\n\\n        $out[] = $tagger->getChunk($rowTpl, $phs);\\n    }\\n\\n    $idx++;\\n}\\n\\n$out = implode($separator, $out);\\n\\nif ($outTpl != \'\') {\\n    if (!empty($out) || $wrapIfEmpty) {\\n        $out = $tagger->getChunk($outTpl, array(\'tags\' => $out));\\n    }\\n}\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $out);\\n    return \'\';\\n}\\n\\nreturn $out;","locked":0,"properties":"a:15:{s:9:\\"resources\\";a:7:{s:4:\\"name\\";s:9:\\"resources\\";s:4:\\"desc\\";s:29:\\"tagger.gettags.resources_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"groups\\";a:7:{s:4:\\"name\\";s:6:\\"groups\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.groups_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"rowTpl\\";a:7:{s:4:\\"name\\";s:6:\\"rowTpl\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.rowTpl_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"outTpl\\";a:7:{s:4:\\"name\\";s:6:\\"outTpl\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.outTpl_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:9:\\"separator\\";a:7:{s:4:\\"name\\";s:9:\\"separator\\";s:4:\\"desc\\";s:29:\\"tagger.gettags.separator_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"target\\";a:7:{s:4:\\"name\\";s:6:\\"target\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.target_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:10:\\"showUnused\\";a:7:{s:4:\\"name\\";s:10:\\"showUnused\\";s:4:\\"desc\\";s:30:\\"tagger.gettags.showUnused_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:15:\\"showUnpublished\\";a:7:{s:4:\\"name\\";s:15:\\"showUnpublished\\";s:4:\\"desc\\";s:35:\\"tagger.gettags.showUnpublished_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:11:\\"showDeleted\\";a:7:{s:4:\\"name\\";s:11:\\"showDeleted\\";s:4:\\"desc\\";s:31:\\"tagger.gettags.showDeleted_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"contexts\\";a:7:{s:4:\\"name\\";s:8:\\"contexts\\";s:4:\\"desc\\";s:28:\\"tagger.gettags.contexts_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:13:\\"toPlaceholder\\";a:7:{s:4:\\"name\\";s:13:\\"toPlaceholder\\";s:4:\\"desc\\";s:33:\\"tagger.gettags.toPlaceholder_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:5:\\"limit\\";a:7:{s:4:\\"name\\";s:5:\\"limit\\";s:4:\\"desc\\";s:25:\\"tagger.gettags.limit_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"offset\\";a:7:{s:4:\\"name\\";s:6:\\"offset\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.offset_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:7:\\"totalPh\\";a:7:{s:4:\\"name\\";s:7:\\"totalPh\\";s:4:\\"desc\\";s:27:\\"tagger.gettags.totalPh_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:10:\\"tags_total\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:4:\\"sort\\";a:7:{s:4:\\"name\\";s:4:\\"sort\\";s:4:\\"desc\\";s:24:\\"tagger.gettags.sort_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:14:\\"{\\"tag\\": \\"asc\\"}\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetTags\\n *\\n * DESCRIPTION\\n *\\n * This Snippet allows you to list tags for resource(s), group(s) and all tags\\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &rowTpl          string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl          string  optional    Name of a chunk that will be used for wrapping all tags. If no chunk is given, tags will be rendered without a wrapper\\n * &separator       string  optional    String separator, that will be used for separating Tags\\n * &limit           int     optional    Limit number of returned tag Tags\\n * &offset          int     optional    Offset the output by this number of Tags\\n * &totalPh         string  optional    Placeholder to output the total number of Tags regardless of &limit and &offset\\n * &target          int     optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * &toPlaceholder   string  optional    If set, output will return in placeholder with given name\\n * &sort            string  optional    Sort options in JSON. Example {\\"tag\\": \\"ASC\\"} or multiple sort options {\\"group_id\\": \\"ASC\\", \\"tag\\": \\"ASC\\"}\\n * &friendlyURL     int     optional    If set, will be used instead of friendly_urls system setting to generate URL\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetTags? &showUnused=`1`]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$showUnused = (int) $modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int) $modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int) $modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n$translate = (int) $modx->getOption(\'translate\', $scriptProperties, \'0\');\\n\\n$defaultRowTpl = $modx->getOption(\'rowTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, 1);\\n$separator = $modx->getOption(\'separator\', $scriptProperties, \'\');\\n$limit = intval($modx->getOption(\'limit\', $scriptProperties, 0));\\n$offset = intval($modx->getOption(\'offset\', $scriptProperties, 0));\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$weight = (int) $modx->getOption(\'weight\', $scriptProperties, \'0\');\\n\\n$friendlyURL = $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'{}\');\\n$sort = $modx->fromJSON($sort);\\nif ($sort === null || $sort == \'\' || count($sort) == 0) {\\n    $sort = array(\\n        \'tag\' => \'ASC\'\\n    );\\n}\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, \'\');\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\\n        \'Resource.context_key:IN\' => $contexts,\\n    ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n    ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n    ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\\n        \'cnt > 0\',\\n    ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\\n        \'Resources.resource:IN\' => $resources\\n    ));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n    ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) as total, MAX(cnt) as max_cnt FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\n\\nif ($stmt && $stmt->execute()) {\\n    $fetchedData = $stmt->fetch(PDO::FETCH_ASSOC);\\n    $total = intval($fetchedData[\'total\']);\\n    $maxCnt = intval($fetchedData[\'max_cnt\']);\\n} else {\\n    $total = 0;\\n    $maxCnt = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\nforeach ($sort as $field => $dir) {\\n    $dir = (strtolower($dir) == \'asc\') ? \'asc\' : \'desc\';\\n    $c->sortby($field, $dir);\\n}\\n\\n$c->limit($limit, $offset);\\n\\n$tags = $modx->getIterator(\'TaggerTag\', $c);\\n\\n$out = array();\\n\\n\\/\\/ prep for &tpl_N\\n$keys = array_keys($scriptProperties);\\n$nthTpls = array();\\nforeach($keys as $key) {\\n    $keyBits = $tagger->explodeAndClean($key, \'_\');\\n    if (isset($keyBits[0]) && $keyBits[0] === \'tpl\') {\\n        if ($i = (int) $keyBits[1]) $nthTpls[$i] = $scriptProperties[$key];\\n    }\\n}\\nksort($nthTpls);\\n\\n$idx = 1;\\nforeach ($tags as $tag) {\\n    \\/** @var TaggerTag $tag *\\/\\n    $phs = $tag->toArray();\\n\\n    $group = $tag->Group;\\n\\n    if ($friendlyURL == 1) {\\n        $uri = rtrim($modx->makeUrl($target, \'\', \'\'), \'\\/\') . \'\\/\' . $group->alias . \'\\/\' . $tag->alias . \'\\/\';\\n    } else {\\n        $uri = $modx->makeUrl($target, \'\', $group->alias . \'=\' . $tag->alias);\\n    }\\n\\n    $phs[\'uri\'] = $uri;\\n    $phs[\'idx\'] = $idx;\\n    $phs[\'target\'] = $target;\\n    $phs[\'max_cnt\'] = $maxCnt;\\n\\n    if ($weight > 0) {\\n        $phs[\'weight\'] = intval(ceil($phs[\'cnt\'] \\/ ($maxCnt \\/ $weight)));\\n    }\\n\\n    if ($translate == 1) {\\n        $groupNameTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\']);\\n        $groupDescriptionTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\');\\n\\n        $phs[\'group_name_translated\'] = ($groupNameTranslated == \'tagger.custom.\' . $phs[\'group_alias\']) ? $phs[\'group_name\'] : $groupNameTranslated;\\n        $phs[\'group_description_translated\'] = ($groupDescriptionTranslated == \'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\') ? $phs[\'group_description\'] : $groupDescriptionTranslated;\\n    }\\n\\n    $rowTpl = $defaultRowTpl;\\n    if ($rowTpl == \'\') {\\n        $out[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n    } else {\\n        if (isset($nthTpls[$idx])) {\\n            $rowTpl = $nthTpls[$idx];\\n        } else {\\n            foreach ($nthTpls as $int => $tpl) {\\n                if ( ($idx % $int) === 0 ) $rowTpl = $tpl;\\n            }\\n        }\\n\\n        $out[] = $tagger->getChunk($rowTpl, $phs);\\n    }\\n\\n    $idx++;\\n}\\n\\n$out = implode($separator, $out);\\n\\nif ($outTpl != \'\') {\\n    if (!empty($out) || $wrapIfEmpty) {\\n        $out = $tagger->getChunk($outTpl, array(\'tags\' => $out));\\n    }\\n}\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $out);\\n    return \'\';\\n}\\n\\nreturn $out;"}',
        'guid' => '13810e3e96d6ae1dfabfd0cb0f5ac903',
        'native_key' => 0,
        'signature' => '796600e2b18f7fa3784fec85f01f8fd2',
      ),
      'd15a882cc8ef2e6c0922b4f0704fdf7a' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":1,"source":0,"property_preprocess":0,"name":"TaggerGetResourcesWhere","description":"This snippet generate SQL Query that can be used in WHERE condition in getResources snippet","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetResourcesWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generate SQL Query that can be used in WHERE condition in getResources snippet\\n *\\n * PROPERTIES:\\n *\\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0\\n * &field           string  optional    modResource field that will be used to compare with assigned resource ID\\n *\\n * USAGE:\\n *\\n * [[!getResources? &where=`[[!TaggerGetResourcesWhere? &tags=`Books,Vehicles` &where=`{\\"isfolder\\": 0}`]]`]]\\n *\\n *\\/\\n\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$tags = $modx->getOption(\'tags\', $scriptProperties, \'\');\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$tagField = $modx->getOption(\'tagField\', $scriptProperties, \'alias\');\\n$likeComparison = (int) $modx->getOption(\'likeComparison\', $scriptProperties, 0);\\n$matchAll = (int) $modx->getOption(\'matchAll\', $scriptProperties, 0);\\n$field = $modx->getOption(\'field\', $scriptProperties, \'id\');\\n$where = $modx->fromJSON($where);\\nif ($where == false) {\\n    $where = array();\\n}\\n\\n$tagsCount = 0;\\n\\nif ($tags == \'\') {\\n    $gc = $modx->newQuery(\'TaggerGroup\');\\n    $gc->select($modx->getSelectColumns(\'TaggerGroup\', \'\', \'\', array(\'alias\')));\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n    $groups = $tagger->explodeAndClean($groups);\\n    if (!empty($groups)) {\\n        $gc->where(array(\\n            \'name:IN\' => $groups,\\n            \'OR:alias:IN\' => $groups,\\n            \'OR:id:IN\' => $groups,\\n        ));\\n    }\\n\\n    $gc->prepare();\\n    $gc->stmt->execute();\\n    $groups = $gc->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\n    $conditions = array();\\n    foreach ($groups as $group) {\\n        if (isset($_GET[$group])) {\\n            $groupTags = $tagger->explodeAndClean($_GET[$group]);\\n            if (!empty($groupTags)) {\\n                $like = array(\'AND:alias:IN\' => $groupTags);\\n\\n                if ($likeComparison == 1) {\\n                    foreach ($groupTags as $tag) {\\n                        $like[] = array(\'OR:alias:LIKE\' => \'%\' . $tag . \'%\');\\n                    }\\n                }\\n\\n                $conditions[] = array(\\n                    \'OR:Group.alias:=\' => $group,\\n                    $like\\n                );\\n                $tagsCount += count($groupTags);\\n            }\\n        }\\n    }\\n\\n    if (count($conditions) == 0) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->leftJoin(\'TaggerGroup\', \'Group\');\\n\\n    $c->where($conditions);\\n} else {\\n    $tags = $tagger->explodeAndClean($tags);\\n\\n    if (empty($tags)) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $tagsCount = count($tags);\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n\\n    $groups = $tagger->explodeAndClean($groups);\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\', \'\', array(\'id\')));\\n\\n    $compare = array(\\n        $tagField . \':IN\' => $tags\\n    );\\n\\n    if ($likeComparison == 1) {\\n        foreach ($tags as $tag) {\\n            $compare[] = array(\'OR:\' . $tagField . \':LIKE\' => \'%\' . $tag . \'%\');\\n        }\\n    }\\n\\n    $c->where($compare);\\n\\n    if (!empty($groups)) {\\n        $c->leftJoin(\'TaggerGroup\', \'Group\');\\n        $c->where(array(\\n            \'Group.id:IN\' => $groups,\\n            \'OR:Group.name:IN\' => $groups,\\n            \'OR:Group.alias:IN\' => $groups,\\n        ));\\n    }\\n}\\n\\n$c->prepare();\\n$c->stmt->execute();\\n$tagIDs = $c->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\nif (count($tagIDs) == 0) {\\n    $tagIDs[] = 0;\\n}\\n\\nif ($matchAll == 0) {\\n    $where[] = \\"EXISTS (SELECT 1 FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\")\\";\\n} else {\\n    $where[] = \\"EXISTS (SELECT 1 as found FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\" GROUP BY found HAVING count(found) = \\" . $tagsCount . \\")\\";\\n}\\n\\nreturn $modx->toJSON($where);","locked":0,"properties":"a:6:{s:4:\\"tags\\";a:7:{s:4:\\"name\\";s:4:\\"tags\\";s:4:\\"desc\\";s:34:\\"tagger.getresourceswhere.tags_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"groups\\";a:7:{s:4:\\"name\\";s:6:\\"groups\\";s:4:\\"desc\\";s:36:\\"tagger.getresourceswhere.groups_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:5:\\"where\\";a:7:{s:4:\\"name\\";s:5:\\"where\\";s:4:\\"desc\\";s:35:\\"tagger.getresourceswhere.where_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:14:\\"likeComparison\\";a:7:{s:4:\\"name\\";s:14:\\"likeComparison\\";s:4:\\"desc\\";s:44:\\"tagger.getresourceswhere.likeComparison_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"tagField\\";a:7:{s:4:\\"name\\";s:8:\\"tagField\\";s:4:\\"desc\\";s:38:\\"tagger.getresourceswhere.tagField_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:5:\\"alias\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"matchAll\\";a:7:{s:4:\\"name\\";s:8:\\"matchAll\\";s:4:\\"desc\\";s:38:\\"tagger.getresourceswhere.matchAll_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetResourcesWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generate SQL Query that can be used in WHERE condition in getResources snippet\\n *\\n * PROPERTIES:\\n *\\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0\\n * &field           string  optional    modResource field that will be used to compare with assigned resource ID\\n *\\n * USAGE:\\n *\\n * [[!getResources? &where=`[[!TaggerGetResourcesWhere? &tags=`Books,Vehicles` &where=`{\\"isfolder\\": 0}`]]`]]\\n *\\n *\\/\\n\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$tags = $modx->getOption(\'tags\', $scriptProperties, \'\');\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$tagField = $modx->getOption(\'tagField\', $scriptProperties, \'alias\');\\n$likeComparison = (int) $modx->getOption(\'likeComparison\', $scriptProperties, 0);\\n$matchAll = (int) $modx->getOption(\'matchAll\', $scriptProperties, 0);\\n$field = $modx->getOption(\'field\', $scriptProperties, \'id\');\\n$where = $modx->fromJSON($where);\\nif ($where == false) {\\n    $where = array();\\n}\\n\\n$tagsCount = 0;\\n\\nif ($tags == \'\') {\\n    $gc = $modx->newQuery(\'TaggerGroup\');\\n    $gc->select($modx->getSelectColumns(\'TaggerGroup\', \'\', \'\', array(\'alias\')));\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n    $groups = $tagger->explodeAndClean($groups);\\n    if (!empty($groups)) {\\n        $gc->where(array(\\n            \'name:IN\' => $groups,\\n            \'OR:alias:IN\' => $groups,\\n            \'OR:id:IN\' => $groups,\\n        ));\\n    }\\n\\n    $gc->prepare();\\n    $gc->stmt->execute();\\n    $groups = $gc->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\n    $conditions = array();\\n    foreach ($groups as $group) {\\n        if (isset($_GET[$group])) {\\n            $groupTags = $tagger->explodeAndClean($_GET[$group]);\\n            if (!empty($groupTags)) {\\n                $like = array(\'AND:alias:IN\' => $groupTags);\\n\\n                if ($likeComparison == 1) {\\n                    foreach ($groupTags as $tag) {\\n                        $like[] = array(\'OR:alias:LIKE\' => \'%\' . $tag . \'%\');\\n                    }\\n                }\\n\\n                $conditions[] = array(\\n                    \'OR:Group.alias:=\' => $group,\\n                    $like\\n                );\\n                $tagsCount += count($groupTags);\\n            }\\n        }\\n    }\\n\\n    if (count($conditions) == 0) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->leftJoin(\'TaggerGroup\', \'Group\');\\n\\n    $c->where($conditions);\\n} else {\\n    $tags = $tagger->explodeAndClean($tags);\\n\\n    if (empty($tags)) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $tagsCount = count($tags);\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n\\n    $groups = $tagger->explodeAndClean($groups);\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\', \'\', array(\'id\')));\\n\\n    $compare = array(\\n        $tagField . \':IN\' => $tags\\n    );\\n\\n    if ($likeComparison == 1) {\\n        foreach ($tags as $tag) {\\n            $compare[] = array(\'OR:\' . $tagField . \':LIKE\' => \'%\' . $tag . \'%\');\\n        }\\n    }\\n\\n    $c->where($compare);\\n\\n    if (!empty($groups)) {\\n        $c->leftJoin(\'TaggerGroup\', \'Group\');\\n        $c->where(array(\\n            \'Group.id:IN\' => $groups,\\n            \'OR:Group.name:IN\' => $groups,\\n            \'OR:Group.alias:IN\' => $groups,\\n        ));\\n    }\\n}\\n\\n$c->prepare();\\n$c->stmt->execute();\\n$tagIDs = $c->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\nif (count($tagIDs) == 0) {\\n    $tagIDs[] = 0;\\n}\\n\\nif ($matchAll == 0) {\\n    $where[] = \\"EXISTS (SELECT 1 FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\")\\";\\n} else {\\n    $where[] = \\"EXISTS (SELECT 1 as found FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\" GROUP BY found HAVING count(found) = \\" . $tagsCount . \\")\\";\\n}\\n\\nreturn $modx->toJSON($where);"}',
        'guid' => 'c57c0e6e83ab27ae66cbc0b4158d47cb',
        'native_key' => 1,
        'signature' => '6adc75f9a210cb69f86a7e2f91d14337',
      ),
      'c47c8599e35ff1a8f433934c23992156' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":0,"source":0,"property_preprocess":0,"name":"TaggerGetRelatedWhere","description":"This Snippet allows you to list related resources","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetRelatedWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generates a SQL Query that can be used in WHERE condition in getResources snippet\\n * to get related resources, which have the same tags \\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags. Default: current resource\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * \\n * TaggerGetResourcesWhere - PROPERTIES:\\n * \\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0 \\n *\\n * USAGE:\\n *\\n * [[!TaggerGetRelatedWhere? &groups=`1` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/**\\n @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, is_object($modx->resource) ? $modx->resource->get(\'id\') : \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$showUnused = (int)$modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int)$modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int)$modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\'Resource.context_key:IN\' => $contexts, ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n        ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n        ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\'cnt > 0\', ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\'Resources.resource:IN\' => $resources));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n        ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n\\/\\/$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\nif ($stmt && $stmt->execute()) {\\n    $total = intval($stmt->fetchColumn());\\n} else {\\n    $total = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\n$tags = array();\\n\\nif ($collection = $modx->getIterator(\'TaggerTag\', $c)) {\\n    foreach ($collection as $tag) {\\n        $tags[] = $tag->get(\'tag\');\\n    }\\n}\\n\\n$wherecondition = array(\'id:not IN\' => $resources);\\n\\n$scriptProperties[\'where\'] = $modx->toJson($wherecondition);\\n\\n$output = \'{\\"template\\":\\"99999999\\"}\';\\n\\nif (count($tags)) {\\n    $scriptProperties[\'tags\'] = implode(\',\', $tags);\\n    $output = $modx->runSnippet(\'TaggerGetResourcesWhere\', $scriptProperties);\\n}\\n\\nreturn $output;","locked":0,"properties":null,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetRelatedWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generates a SQL Query that can be used in WHERE condition in getResources snippet\\n * to get related resources, which have the same tags \\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags. Default: current resource\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * \\n * TaggerGetResourcesWhere - PROPERTIES:\\n * \\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0 \\n *\\n * USAGE:\\n *\\n * [[!TaggerGetRelatedWhere? &groups=`1` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/**\\n @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, is_object($modx->resource) ? $modx->resource->get(\'id\') : \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$showUnused = (int)$modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int)$modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int)$modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\'Resource.context_key:IN\' => $contexts, ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n        ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n        ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\'cnt > 0\', ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\'Resources.resource:IN\' => $resources));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n        ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n\\/\\/$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\nif ($stmt && $stmt->execute()) {\\n    $total = intval($stmt->fetchColumn());\\n} else {\\n    $total = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\n$tags = array();\\n\\nif ($collection = $modx->getIterator(\'TaggerTag\', $c)) {\\n    foreach ($collection as $tag) {\\n        $tags[] = $tag->get(\'tag\');\\n    }\\n}\\n\\n$wherecondition = array(\'id:not IN\' => $resources);\\n\\n$scriptProperties[\'where\'] = $modx->toJson($wherecondition);\\n\\n$output = \'{\\"template\\":\\"99999999\\"}\';\\n\\nif (count($tags)) {\\n    $scriptProperties[\'tags\'] = implode(\',\', $tags);\\n    $output = $modx->runSnippet(\'TaggerGetResourcesWhere\', $scriptProperties);\\n}\\n\\nreturn $output;"}',
        'guid' => '2e75b5efb8c6440dea057b1dfb1b412d',
        'native_key' => 0,
        'signature' => '01d211515621ea8cf07d1f8185b23342',
      ),
    ),
    'Plugins' => 
    array (
      '34291b6aaae52c9fba6179bf99453300' => 
      array (
        'unique_key' => 'name',
        'preserve_keys' => false,
        'update_object' => true,
        'related_objects' => 
        array (
          'PluginEvents' => 
          array (
            '305a3a77540fb18cca1c0e43ef5c45c2' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnDocFormSave","priority":0,"propertyset":0}',
              'guid' => 'dbbea1fc0c125d2dfa44a7c2935a16d8',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnDocFormSave',
              ),
              'signature' => 'f6202af9d6f43c60ac71b6a9343293be',
            ),
            '5d8bf03241c1b018b83d882e3d7fd8c5' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnDocFormPrerender","priority":0,"propertyset":0}',
              'guid' => '95122d3e6986e477d936a5804b229040',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnDocFormPrerender',
              ),
              'signature' => 'c0cda992cf2904386205547cfa522049',
            ),
            'd41f61c178afdb5c08f29e6f157f9ca9' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnHandleRequest","priority":0,"propertyset":0}',
              'guid' => '04e063f40869a3e73145209dd3ff80b7',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnHandleRequest',
              ),
              'signature' => '1f5cac38c262d328d54ee1ea5dc36abe',
            ),
            '0434ea3d374fb751c596c422e5ad0b21' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnResourceDuplicate","priority":0,"propertyset":0}',
              'guid' => '2401efa030f42eac0408175801282be9',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnResourceDuplicate',
              ),
              'signature' => 'ed4a3a1ef5e9294c841064fbe1229d14',
            ),
          ),
        ),
        'related_object_attributes' => 
        array (
          'PluginEvents' => 
          array (
            'preserve_keys' => true,
            'update_object' => false,
            'unique_key' => 
            array (
              0 => 'pluginid',
              1 => 'event',
            ),
          ),
        ),
        'class' => 'modPlugin',
        'object' => '{"id":1,"source":0,"property_preprocess":0,"name":"Tagger","description":"This plugin inject Tagger tab into Resource panel and handles saving of tags.","editor_type":0,"category":0,"cache_type":0,"plugincode":"\\/**\\n * Tagger\\n *\\n * DESCRIPTION\\n *\\n * This plugin inject JS to add Tab with tag groups into Resource panel\\n *\\/\\n\\n$corePath = $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components\\/tagger\\/\');\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\\n    \'tagger\',\\n    \'Tagger\',\\n    $corePath . \'model\\/tagger\\/\',\\n    array(\\n        \'core_path\' => $corePath\\n    )\\n);\\n\\n$className = \'Tagger\' . $modx->event->name;\\n$modx->loadClass(\'TaggerPlugin\', $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n$modx->loadClass($className, $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n\\nif (class_exists($className)) {\\n    \\/** @var TaggerPlugin $handler *\\/\\n    $handler = new $className($modx, $scriptProperties);\\n    $handler->run();\\n}\\n\\nreturn;","locked":0,"properties":null,"disabled":0,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * Tagger\\n *\\n * DESCRIPTION\\n *\\n * This plugin inject JS to add Tab with tag groups into Resource panel\\n *\\/\\n\\n$corePath = $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components\\/tagger\\/\');\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\\n    \'tagger\',\\n    \'Tagger\',\\n    $corePath . \'model\\/tagger\\/\',\\n    array(\\n        \'core_path\' => $corePath\\n    )\\n);\\n\\n$className = \'Tagger\' . $modx->event->name;\\n$modx->loadClass(\'TaggerPlugin\', $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n$modx->loadClass($className, $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n\\nif (class_exists($className)) {\\n    \\/** @var TaggerPlugin $handler *\\/\\n    $handler = new $className($modx, $scriptProperties);\\n    $handler->run();\\n}\\n\\nreturn;"}',
        'guid' => '8c95ed6afb92905943994c9cf12a20a3',
        'native_key' => 1,
        'signature' => 'e82a1a07f827bb671be15db900157ad2',
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Plugins' => 
    array (
      'unique_key' => 'name',
      'preserve_keys' => false,
      'update_object' => true,
      'related_objects' => true,
      'related_object_attributes' => 
      array (
        'PluginEvents' => 
        array (
          'preserve_keys' => true,
          'update_object' => false,
          'unique_key' => 
          array (
            0 => 'pluginid',
            1 => 'event',
          ),
        ),
      ),
    ),
  ),
  'namespace' => 'tagger',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.7.0-pl\\/modCategory\\/177b539a3e5f8488c32b94c91b2c1cc9.resolve.remove_tables.resolver","type":"php","name":"resolve.remove_tables"}',
    ),
    1 => 
    array (
      'type' => 'file',
      'body' => '{"source":"tagger-1.7.0-pl\\/modCategory\\/177b539a3e5f8488c32b94c91b2c1cc9\\/1\\/","target":"return MODX_ASSETS_PATH . \'components\\/\';","name":"tagger"}',
    ),
    2 => 
    array (
      'type' => 'file',
      'body' => '{"source":"tagger-1.7.0-pl\\/modCategory\\/177b539a3e5f8488c32b94c91b2c1cc9\\/2\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"tagger"}',
    ),
    3 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.7.0-pl\\/modCategory\\/177b539a3e5f8488c32b94c91b2c1cc9.resolve.tables.resolver","type":"php","name":"resolve.tables"}',
    ),
    4 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.7.0-pl\\/modCategory\\/177b539a3e5f8488c32b94c91b2c1cc9.resolve.settings.resolver","type":"php","name":"resolve.settings"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => '4491a8f72ea21b42d0b97bf64f0ffcb7',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => '177b539a3e5f8488c32b94c91b2c1cc9',
  'native_key' => 1,
  'object' => '{"id":1,"parent":0,"category":"Tagger"}',
);